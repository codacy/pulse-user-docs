{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Integrating with Pulse \u00b6 Pulse displays metrics that provide insights into the current and historic performance of your software delivery process. To calculate these metrics, Pulse must collect information from key events of your particular software development workflow. Currently, Pulse provides a push-based integration with your workflow using either \"one-click integrations\" or the Pulse CLI: GitHub integration (reports changes and deployments) PagerDuty integration (reports incidents) Pulse CLI (reports changes, deployments, and incidents) We recommend that you use the integrations that match your stack because they're faster to set up. Creating an organization \u00b6 You must create your own organization on Pulse to start the onboarding. Click the link in the welcome banner at the top of the page and follow the instructions. To add more organizations, click the name of the current organization on the top left-hand corner and select New Organization . Sharing access with teammates \u00b6 Share the Pulse dashboards with your teammates to bring more visibility to the metrics. To do this, copy the link on the Organization members page and share it with your teammates. A convenient way to do this is to share and pin the link on your team's chat. By doing this, the people you invite will have access to all dashboards immediately after signing up without needing to perform any integration. The link is valid for 3 months, but you can refresh it at any moment.","title":"Integrating with Pulse"},{"location":"#integrating-with-pulse","text":"Pulse displays metrics that provide insights into the current and historic performance of your software delivery process. To calculate these metrics, Pulse must collect information from key events of your particular software development workflow. Currently, Pulse provides a push-based integration with your workflow using either \"one-click integrations\" or the Pulse CLI: GitHub integration (reports changes and deployments) PagerDuty integration (reports incidents) Pulse CLI (reports changes, deployments, and incidents) We recommend that you use the integrations that match your stack because they're faster to set up.","title":"Integrating with Pulse"},{"location":"#creating-an-organization","text":"You must create your own organization on Pulse to start the onboarding. Click the link in the welcome banner at the top of the page and follow the instructions. To add more organizations, click the name of the current organization on the top left-hand corner and select New Organization .","title":"Creating an organization"},{"location":"#sharing-access-with-teammates","text":"Share the Pulse dashboards with your teammates to bring more visibility to the metrics. To do this, copy the link on the Organization members page and share it with your teammates. A convenient way to do this is to share and pin the link on your team's chat. By doing this, the people you invite will have access to all dashboards immediately after signing up without needing to perform any integration. The link is valid for 3 months, but you can refresh it at any moment.","title":"Sharing access with teammates"},{"location":"one-click-integrations/","text":"One-click integrations \u00b6 Pulse is developing \"one-click integrations\" for the most popular Git providers, CI/CD platforms, and incident management tools. These integrations simplify the process of setting up your workflows to send data to Pulse. GitHub \u00b6 Pulse integrates directly with GitHub to receive data about changes and deployments, necessary to calculate the metrics: Lead time for changes , including the following drill-down metrics: Lead time for changes sub-metrics Review metrics Work in progress metrics Deployment frequency Setting up the GitHub integration \u00b6 To set up the GitHub integration: On Pulse, expand Integrations and select GitHub . Click Install GitHub App and follow the instructions on the GitHub UI to install the app on your organization. Important You can only install the Pulse GitHub App on an organization and not on your personal account. Wait until you get a confirmation that Pulse successfully created the integration and the webhook on GitHub. If there was an error please contact support . Configuring how Pulse detects deployments \u00b6 Optionally, the Pulse GitHub integration can use one of two strategies to automatically detect and measure deployments in your repositories: Pull requests merged to default branch (default strategy) Pulse considers a deployment every pull request that targets the default branch of the repository. The deployment date is the timestamp when the corresponding pull request is merged. The set of changes in a deployment is the list of commits in the corresponding pull request. Pulse correctly tracks your changes even if you squash the commits when merging the pull request. Git tags following the SemVer specification Pulse considers a deployment every Git tag that follows the SemVer convention, excluding pre-release versions but allowing release prefixes. For exmple, the following are valid tags: 1.0.0 , v2.3.4 . To use this strategy, make sure that you're creating Git tags on your repositories for each successful deployment to production, or whenever you make a new release available to any user of your application: git tag -a MAJOR.MINOR.PATCH -m \"<Deployment or release message>\" Where MAJOR.MINOR.PATCH must be a valid SemVer version without pre-release information. The deployment date is either the creation date of annotated tags or the timestamp when Pulse receives the webhook calls for lightweight tags . Keep in mind that since webhook calls can be delayed, the deployment date on Pulse could be imprecise and impact the metric Lead time for changes . The set of changes that belong to a deployment is the list of commits between the tag of that deployment and the previous tag. Because of this, Pulse discards: The first SemVer tag in the repository since there is no previous tag to compare with. Any tag that does not have a common ancestor (commit) with its previous tag, since Pulse cannot obtain the changes between them. If the automatic deployment detection is turned off, Pulse doesn't detect deployments using GitHub events and you must report deployments using the Pulse CLI or the API. This is useful if none of the automatic deployment detection strategies match your workflow and you must have control over the way Pulse tracks your deployments. To configure the strategy that Pulse uses to detect deployments: On Pulse, expand Integrations and select GitHub . Make sure that you have already installed the GitHub App. Choose the strategy that fits best your workflows, or turn off the automatic deployment detection. PagerDuty \u00b6 Pulse integrates directly with PagerDuty to receive data about incidents, necessary to calculate the metrics Median time to recover and Change failure rate . To set up the PagerDuty integration: On Pulse, expand Integrations and select PagerDuty . Fill in the necessary details: PagerDuty subdomain: Your custom PagerDuty subdomain. For example, mysubdomain if you use the URL https://mysubdomain.pagerduty.com to access PagerDuty. Pulse system name: Name of the system to associate with the incidents reported by this integration. Follow the instructions on the Pulse UI to create a new webhook on PagerDuty using the provided URL. For example:","title":"One-click integrations"},{"location":"one-click-integrations/#one-click-integrations","text":"Pulse is developing \"one-click integrations\" for the most popular Git providers, CI/CD platforms, and incident management tools. These integrations simplify the process of setting up your workflows to send data to Pulse.","title":"One-click integrations"},{"location":"one-click-integrations/#github","text":"Pulse integrates directly with GitHub to receive data about changes and deployments, necessary to calculate the metrics: Lead time for changes , including the following drill-down metrics: Lead time for changes sub-metrics Review metrics Work in progress metrics Deployment frequency","title":"GitHub"},{"location":"one-click-integrations/#setting-up-the-github-integration","text":"To set up the GitHub integration: On Pulse, expand Integrations and select GitHub . Click Install GitHub App and follow the instructions on the GitHub UI to install the app on your organization. Important You can only install the Pulse GitHub App on an organization and not on your personal account. Wait until you get a confirmation that Pulse successfully created the integration and the webhook on GitHub. If there was an error please contact support .","title":"Setting up the GitHub integration"},{"location":"one-click-integrations/#deployment-detection-strategy","text":"Optionally, the Pulse GitHub integration can use one of two strategies to automatically detect and measure deployments in your repositories: Pull requests merged to default branch (default strategy) Pulse considers a deployment every pull request that targets the default branch of the repository. The deployment date is the timestamp when the corresponding pull request is merged. The set of changes in a deployment is the list of commits in the corresponding pull request. Pulse correctly tracks your changes even if you squash the commits when merging the pull request. Git tags following the SemVer specification Pulse considers a deployment every Git tag that follows the SemVer convention, excluding pre-release versions but allowing release prefixes. For exmple, the following are valid tags: 1.0.0 , v2.3.4 . To use this strategy, make sure that you're creating Git tags on your repositories for each successful deployment to production, or whenever you make a new release available to any user of your application: git tag -a MAJOR.MINOR.PATCH -m \"<Deployment or release message>\" Where MAJOR.MINOR.PATCH must be a valid SemVer version without pre-release information. The deployment date is either the creation date of annotated tags or the timestamp when Pulse receives the webhook calls for lightweight tags . Keep in mind that since webhook calls can be delayed, the deployment date on Pulse could be imprecise and impact the metric Lead time for changes . The set of changes that belong to a deployment is the list of commits between the tag of that deployment and the previous tag. Because of this, Pulse discards: The first SemVer tag in the repository since there is no previous tag to compare with. Any tag that does not have a common ancestor (commit) with its previous tag, since Pulse cannot obtain the changes between them. If the automatic deployment detection is turned off, Pulse doesn't detect deployments using GitHub events and you must report deployments using the Pulse CLI or the API. This is useful if none of the automatic deployment detection strategies match your workflow and you must have control over the way Pulse tracks your deployments. To configure the strategy that Pulse uses to detect deployments: On Pulse, expand Integrations and select GitHub . Make sure that you have already installed the GitHub App. Choose the strategy that fits best your workflows, or turn off the automatic deployment detection.","title":"Configuring how Pulse detects deployments"},{"location":"one-click-integrations/#pagerduty","text":"Pulse integrates directly with PagerDuty to receive data about incidents, necessary to calculate the metrics Median time to recover and Change failure rate . To set up the PagerDuty integration: On Pulse, expand Integrations and select PagerDuty . Fill in the necessary details: PagerDuty subdomain: Your custom PagerDuty subdomain. For example, mysubdomain if you use the URL https://mysubdomain.pagerduty.com to access PagerDuty. Pulse system name: Name of the system to associate with the incidents reported by this integration. Follow the instructions on the Pulse UI to create a new webhook on PagerDuty using the provided URL. For example:","title":"PagerDuty"},{"location":"cli/examples/","text":"Examples \u00b6 This page includes examples of scripts that we used to quickly populate our own Pulse dashboard with historical data. You can use the examples to understand better how you can integrate the Pulse CLI with your existing workflows, or adapt these examples to populate your Pulse dashboard with historical data from your team. Pushing historic changes and deployments \u00b6 In this example, we used the Pulse CLI to push past changes and deployments from a Git repository into Pulse. Deployments are identified using semantic version Git tags, and the changes are the commits included in those deployments. # example.sh #!/usr/bin/env bash set -e CREDENTIALS = \"xxx\" workdir = $( mktemp -d -t website-dora-XXXXXXXXXX ) function clean { rm -rf ${ workdir } } trap clean EXIT git clone git@bitbucket.org:qamine/codacy-website \" $workdir \" cd ${ workdir } mapfile -t deployments < < ( git for -each-ref --sort = creatordate --format '%(refname) %(objectname)' refs/tags | grep -E '^refs\\/tags\\/[0-9]+\\.[0-9]+\\.[0-9]+\\s' | awk -F \"\\/\" '{print $3}' ) previous_deployment = \"\" current_deployment = \"\" for deployment in \" ${ deployments [@] } \" do deployment_id = $( echo \" ${ deployment } \" | awk '{print $1}' ) deployment_sha = $( echo \" ${ deployment } \" | awk '{print $2}' ) deployment_date = $( git log --format = \"%at\" ${ deployment_sha } | head -n 1 ) # Skip deployments before date # If you are on macOS you need to use $(date -jf \"%b %d %Y\" \"Oct 01 2020\" +%s) instead if [ ${ deployment_date } -lt $( date -d \"Oct 01 2020\" +%s ) ] then continue fi if [ -z \" ${ previous_deployment } \" ] then previous_deployment = \" ${ deployment_sha } \" continue else current_deployment = \" ${ deployment_sha } \" deployment_changes =() mapfile -t deployment_changes < < ( git log --format = \"%H\" ${ previous_deployment } ... ${ current_deployment } ) if [ ${# deployment_changes [@] } -gt 0 ] then echo \"Pushing deployment ${ deployment_id } with changes [ ${ deployment_changes [@] } ]\" ./pulse-event-cli push deployment \\ --api-key \" ${ CREDENTIALS } \" \\ --identifier \" ${ deployment_id } \" \\ --timestamp \" ${ deployment_date } \" \\ ${ deployment_changes [@] } for deployment_change in \" ${ deployment_changes [@] } \" do deployment_change_date = $( git log --format = \"%at\" ${ deployment_change } --max-count = 1 ) echo \"Pushing changes ${ deployment_change } with date ${ deployment_change_date } \" ./pulse-event-cli push change \\ --api-key \" ${ CREDENTIALS } \" \\ --identifier \" ${ deployment_change } \" \\ --timestamp \" ${ deployment_change_date } \" done fi previous_deployment = \" ${ deployment_sha } \" fi done Pushing historic incidents \u00b6 In this example, we used the Pulse CLI to push past incidents from the Codacy status page API into Pulse. # incidents.py import requests import subprocess from datetime import datetime , timezone url = 'https://status.codacy.com/api/incidents' resp = requests . get ( url = url ) data = resp . json () def convert_to_unix_epoch ( date_time_str ): return str ( int ( datetime . strptime ( date_time_str , '%Y-%m- %d T%H:%M:%S. %f Z' ) . replace ( tzinfo = timezone . utc ) . timestamp ())) for incident in data : id = incident [ 'incidentID' ] created = convert_to_unix_epoch ( incident [ 'createdAt' ]) updated = convert_to_unix_epoch ( incident [ 'updatedAt' ]) if incident [ 'status' ] == 'Resolved' : print ( f 'Pushing incident { id } created in { created } and resolved at { updated } ' ) print ( created ) print ( updated ) bashCmd = [ \"./pulse-event-cli\" , \"push\" , \"incident\" , \"--api-key\" , \"xxx\" , \"--identifier\" , id , \"--timestampCreated\" , created , \"--timestampResolved\" , updated ] process = subprocess . Popen ( bashCmd , stdout = subprocess . PIPE ) output , error = process . communicate () else : print ( f \"Skipping incident { id } because it was not resolved\" )","title":"Examples"},{"location":"cli/examples/#examples","text":"This page includes examples of scripts that we used to quickly populate our own Pulse dashboard with historical data. You can use the examples to understand better how you can integrate the Pulse CLI with your existing workflows, or adapt these examples to populate your Pulse dashboard with historical data from your team.","title":"Examples"},{"location":"cli/examples/#pushing-historic-changes-and-deployments","text":"In this example, we used the Pulse CLI to push past changes and deployments from a Git repository into Pulse. Deployments are identified using semantic version Git tags, and the changes are the commits included in those deployments. # example.sh #!/usr/bin/env bash set -e CREDENTIALS = \"xxx\" workdir = $( mktemp -d -t website-dora-XXXXXXXXXX ) function clean { rm -rf ${ workdir } } trap clean EXIT git clone git@bitbucket.org:qamine/codacy-website \" $workdir \" cd ${ workdir } mapfile -t deployments < < ( git for -each-ref --sort = creatordate --format '%(refname) %(objectname)' refs/tags | grep -E '^refs\\/tags\\/[0-9]+\\.[0-9]+\\.[0-9]+\\s' | awk -F \"\\/\" '{print $3}' ) previous_deployment = \"\" current_deployment = \"\" for deployment in \" ${ deployments [@] } \" do deployment_id = $( echo \" ${ deployment } \" | awk '{print $1}' ) deployment_sha = $( echo \" ${ deployment } \" | awk '{print $2}' ) deployment_date = $( git log --format = \"%at\" ${ deployment_sha } | head -n 1 ) # Skip deployments before date # If you are on macOS you need to use $(date -jf \"%b %d %Y\" \"Oct 01 2020\" +%s) instead if [ ${ deployment_date } -lt $( date -d \"Oct 01 2020\" +%s ) ] then continue fi if [ -z \" ${ previous_deployment } \" ] then previous_deployment = \" ${ deployment_sha } \" continue else current_deployment = \" ${ deployment_sha } \" deployment_changes =() mapfile -t deployment_changes < < ( git log --format = \"%H\" ${ previous_deployment } ... ${ current_deployment } ) if [ ${# deployment_changes [@] } -gt 0 ] then echo \"Pushing deployment ${ deployment_id } with changes [ ${ deployment_changes [@] } ]\" ./pulse-event-cli push deployment \\ --api-key \" ${ CREDENTIALS } \" \\ --identifier \" ${ deployment_id } \" \\ --timestamp \" ${ deployment_date } \" \\ ${ deployment_changes [@] } for deployment_change in \" ${ deployment_changes [@] } \" do deployment_change_date = $( git log --format = \"%at\" ${ deployment_change } --max-count = 1 ) echo \"Pushing changes ${ deployment_change } with date ${ deployment_change_date } \" ./pulse-event-cli push change \\ --api-key \" ${ CREDENTIALS } \" \\ --identifier \" ${ deployment_change } \" \\ --timestamp \" ${ deployment_change_date } \" done fi previous_deployment = \" ${ deployment_sha } \" fi done","title":"Pushing historic changes and deployments"},{"location":"cli/examples/#pushing-historic-incidents","text":"In this example, we used the Pulse CLI to push past incidents from the Codacy status page API into Pulse. # incidents.py import requests import subprocess from datetime import datetime , timezone url = 'https://status.codacy.com/api/incidents' resp = requests . get ( url = url ) data = resp . json () def convert_to_unix_epoch ( date_time_str ): return str ( int ( datetime . strptime ( date_time_str , '%Y-%m- %d T%H:%M:%S. %f Z' ) . replace ( tzinfo = timezone . utc ) . timestamp ())) for incident in data : id = incident [ 'incidentID' ] created = convert_to_unix_epoch ( incident [ 'createdAt' ]) updated = convert_to_unix_epoch ( incident [ 'updatedAt' ]) if incident [ 'status' ] == 'Resolved' : print ( f 'Pushing incident { id } created in { created } and resolved at { updated } ' ) print ( created ) print ( updated ) bashCmd = [ \"./pulse-event-cli\" , \"push\" , \"incident\" , \"--api-key\" , \"xxx\" , \"--identifier\" , id , \"--timestampCreated\" , created , \"--timestampResolved\" , updated ] process = subprocess . Popen ( bashCmd , stdout = subprocess . PIPE ) output , error = process . communicate () else : print ( f \"Skipping incident { id } because it was not resolved\" )","title":"Pushing historic incidents"},{"location":"cli/installing-the-pulse-cli/","text":"Installing the Pulse CLI \u00b6 Download the latest version of the Pulse CLI for your operating system and make sure that you're able to run the binary. Take note of the latest version of the CLI: Run the command to download the correct binary for your operating system, changing <VERSION> to the latest version obtained on the previous step: Linux On 32-bit operating systems: curl -fsSL -o pulse-event-cli https://artifacts.codacy.com/codacy/pulse/event-cli/<VERSION>/pulse-event-cli_linux_386/pulse-event-cli && \\ chmod +x pulse-event-cli On 64-bit operating systems: curl -fsSL -o pulse-event-cli https://artifacts.codacy.com/codacy/pulse/event-cli/<VERSION>/pulse-event-cli_linux_amd64/pulse-event-cli && \\ chmod +x pulse-event-cli macOS curl -fsSL -o pulse-event-cli https://artifacts.codacy.com/codacy/pulse/event-cli/<VERSION>/pulse-event-cli_darwin_amd64/pulse-event-cli && \\ chmod +x pulse-event-cli Windows On 32-bit operating systems: curl -fsSL -o pulse-event-cli.exe https://artifacts.codacy.com/codacy/pulse/event-cli/<VERSION>/pulse-event-cli_windows_386/pulse-event-cli.exe On 64-bit operating systems: curl -fsSL -o pulse-event-cli.exe https://artifacts.codacy.com/codacy/pulse/event-cli/<VERSION>/pulse-event-cli_windows_amd64/pulse-event-cli.exe Test if you can run the CLI: Linux and macOS ./pulse-event-cli help Windows pulse-event-cli.exe help After installing the CLI you're ready to start pushing data to Pulse .","title":"Installing the Pulse CLI"},{"location":"cli/installing-the-pulse-cli/#installing-the-pulse-cli","text":"Download the latest version of the Pulse CLI for your operating system and make sure that you're able to run the binary. Take note of the latest version of the CLI: Run the command to download the correct binary for your operating system, changing <VERSION> to the latest version obtained on the previous step: Linux On 32-bit operating systems: curl -fsSL -o pulse-event-cli https://artifacts.codacy.com/codacy/pulse/event-cli/<VERSION>/pulse-event-cli_linux_386/pulse-event-cli && \\ chmod +x pulse-event-cli On 64-bit operating systems: curl -fsSL -o pulse-event-cli https://artifacts.codacy.com/codacy/pulse/event-cli/<VERSION>/pulse-event-cli_linux_amd64/pulse-event-cli && \\ chmod +x pulse-event-cli macOS curl -fsSL -o pulse-event-cli https://artifacts.codacy.com/codacy/pulse/event-cli/<VERSION>/pulse-event-cli_darwin_amd64/pulse-event-cli && \\ chmod +x pulse-event-cli Windows On 32-bit operating systems: curl -fsSL -o pulse-event-cli.exe https://artifacts.codacy.com/codacy/pulse/event-cli/<VERSION>/pulse-event-cli_windows_386/pulse-event-cli.exe On 64-bit operating systems: curl -fsSL -o pulse-event-cli.exe https://artifacts.codacy.com/codacy/pulse/event-cli/<VERSION>/pulse-event-cli_windows_amd64/pulse-event-cli.exe Test if you can run the CLI: Linux and macOS ./pulse-event-cli help Windows pulse-event-cli.exe help After installing the CLI you're ready to start pushing data to Pulse .","title":"Installing the Pulse CLI"},{"location":"cli/pushing-data-to-pulse/","text":"Pushing data to Pulse \u00b6 To measure the performance of your team you must send information to Pulse about the following key events whenever they happen in the software delivery workflow of your primary application or service: Changes and deployments Incidents Before you begin \u00b6 Consider the following before setting up the integration using the Pulse CLI: When reporting events to Pulse you should use the field system to associate each event with the most granular unit that you will use to filter data on the Pulse dashboards, such as by application or service, product, team, or any other entity or group of entities in your organization. Important Typically, the value of system should be the name of the CVS repository corresponding to the event. However, if you're using a monorepo the value of system should be the name of the component in the repository instead. Although the field system is optional, if you don't report this information you won't be able to filter the data on the Pulse dashboards. Make sure that you have an API key provided by Pulse to identify your organization and authorize you to send data to Pulse. In some scenarios, it may not be feasible to use the CLI to send data to Pulse, such as when you have the data inside an application. For these situations, you can use the Pulse Ingestion API instead . Changes and deployments \u00b6 Report an event to Pulse whenever your team deploys code to production, including the list of code changes included in that deployment: For SaaS applications, report the event on each deployment to your production environment. For self-hosted applications, a better option is to report the event each time you make an artifact available to any user of your application, such as when you release new binaries or upload a new version to an app store. Pulse uses these reports to calculate the metrics Lead time for changes and Deployment frequency . Using Git \u00b6 If you're using Git, send the following information when reporting changes and deployments to Pulse: Field Description Format previous-deployment-ref Git reference of the previous deployment. This can be a tag or a commit identifier. String identifier Version number or another unique identifier of the deployment. String timestamp Time when the deployment finished. Number (Unix epoch timestamp in seconds) system Optional. Repository or component to assign to this event. String Run the following command to report a deployment and its changes: Linux and macOS git clone <Git repository URL> cd < local Git repository directory> ./pulse-event-cli push git deployment \\ --api-key \"<API key>\" \\ --previous-deployment-ref \"<previous deployment ref>\" \\ --identifier \"<deployment identifier>\" \\ --timestamp \" $( date +%s ) \" \\ [ --system \"<system>\" ] Windows git clone <Git repository URL> cd < local Git repository directory> event-cli.exe push git deployment \\ --api-key \"<API key>\" \\ --previous-deployment-ref \"<previous deployment ref>\" \\ --identifier \"<deployment identifier>\" \\ --timestamp \"<timestamp>\" \\ [ --system \"<system>\" ] The command automatically reports all commits done between the previous deployment and the HEAD of the Git repository as changes that belong to the deployment being reported. Without using Git \u00b6 If you don't use Git or prefer to have more fine-grained control over the information that you send when reporting changes and deployments, send separate reports for each change and deployment as described below. Tip If you're using Git, it's simpler to report changes and deployments together. Send the following information when reporting changes to Pulse: Field Description Format identifier The commit identifier. String timestamp Time when the commit was first pushed to the repository. Number (Unix epoch timestamp in seconds) system Optional. Repository or component to assign to this event. String Run the following command to report each change: Linux and macOS ./pulse-event-cli push change \\ --api-key \"<API key>\" \\ --identifier \"<change identifier>\" \\ --timestamp \" $( date +%s ) \" \\ [ --system \"<system>\" ] Windows event-cli.exe push change \\ --api-key \"<API key>\" \\ --identifier \"<change identifier>\" \\ --timestamp \"<timestamp>\" \\ [ --system \"<system>\" ] Send the following information when reporting deployments to Pulse: Field Description Format identifier Version number or another unique identifier of the deployment. String timestamp Time when the deployment finished. Number (Unix epoch timestamp in seconds) system Optional. Repository or component to assign to this event. String Commit identifiers included in the deployment. String (space-separated list) Run the following command to report each deployment: Linux and macOS ./pulse-event-cli push deployment \\ --api-key \"<API key>\" \\ --identifier \"<deployment identifier>\" \\ --timestamp \" $( date +%s ) \" \\ [ --system \"<system>\" ] \\ <space-separated list of commit identifiers> Windows event-cli.exe push deployment \\ --api-key \"<API key>\" \\ --identifier \"<deployment identifier>\" \\ --timestamp \"<timestamp>\" \\ [ --system \"<system>\" ] \\ <space-separated list of commit identifiers> Incidents \u00b6 Report an event to Pulse whenever an incident resulting from a release or infrastructure configuration change to production is solved. Incidents are any form of degraded service that require remediation: The incident is created when you detect a service impairment or service outage in production. The incident is resolved when you apply a hotfix or patch, or when you rollback the changes to restore the service in production. Typically, it's possible to keep track of this information using your monitoring infrastructure or your ticketing system. Pulse uses these reports to calculate the metrics Median time to recovery and Change failure rate . Send the following information when reporting incidents to Pulse: Field Description Format identifier A unique identifier of the incident. String timestampCreated Time when the incident started or was detected. Number (Unix epoch timestamp in seconds) timestampResolved Time when the incident was resolved. Number (Unix epoch timestamp in seconds) system Optional. Repository or component to assign to this event. String Run the following command to report each incident: Linux and macOS ./pulse-event-cli push incident \\ --api-key \"<API key>\" \\ --identifier \"<incident identifier>\" \\ --timestampCreated \"<timestampCreated>\" \\ --timestampResolved \" $( date +%s ) \" \\ [ --system \"<system>\" ] Windows pulse-event-cli.exe push incident \\ --api-key \"<API key>\" \\ --identifier \"<incident identifier>\" \\ --timestampCreated \"<timestampCreated>\" \\ --timestampResolved \"<timestampResolved>\" \\ [ --system \"<system>\" ]","title":"Pushing data to Pulse"},{"location":"cli/pushing-data-to-pulse/#pushing-data-to-pulse","text":"To measure the performance of your team you must send information to Pulse about the following key events whenever they happen in the software delivery workflow of your primary application or service: Changes and deployments Incidents","title":"Pushing data to Pulse"},{"location":"cli/pushing-data-to-pulse/#before-you-begin","text":"Consider the following before setting up the integration using the Pulse CLI: When reporting events to Pulse you should use the field system to associate each event with the most granular unit that you will use to filter data on the Pulse dashboards, such as by application or service, product, team, or any other entity or group of entities in your organization. Important Typically, the value of system should be the name of the CVS repository corresponding to the event. However, if you're using a monorepo the value of system should be the name of the component in the repository instead. Although the field system is optional, if you don't report this information you won't be able to filter the data on the Pulse dashboards. Make sure that you have an API key provided by Pulse to identify your organization and authorize you to send data to Pulse. In some scenarios, it may not be feasible to use the CLI to send data to Pulse, such as when you have the data inside an application. For these situations, you can use the Pulse Ingestion API instead .","title":"Before you begin"},{"location":"cli/pushing-data-to-pulse/#changes-and-deployments","text":"Report an event to Pulse whenever your team deploys code to production, including the list of code changes included in that deployment: For SaaS applications, report the event on each deployment to your production environment. For self-hosted applications, a better option is to report the event each time you make an artifact available to any user of your application, such as when you release new binaries or upload a new version to an app store. Pulse uses these reports to calculate the metrics Lead time for changes and Deployment frequency .","title":"Changes and deployments"},{"location":"cli/pushing-data-to-pulse/#using-git","text":"If you're using Git, send the following information when reporting changes and deployments to Pulse: Field Description Format previous-deployment-ref Git reference of the previous deployment. This can be a tag or a commit identifier. String identifier Version number or another unique identifier of the deployment. String timestamp Time when the deployment finished. Number (Unix epoch timestamp in seconds) system Optional. Repository or component to assign to this event. String Run the following command to report a deployment and its changes: Linux and macOS git clone <Git repository URL> cd < local Git repository directory> ./pulse-event-cli push git deployment \\ --api-key \"<API key>\" \\ --previous-deployment-ref \"<previous deployment ref>\" \\ --identifier \"<deployment identifier>\" \\ --timestamp \" $( date +%s ) \" \\ [ --system \"<system>\" ] Windows git clone <Git repository URL> cd < local Git repository directory> event-cli.exe push git deployment \\ --api-key \"<API key>\" \\ --previous-deployment-ref \"<previous deployment ref>\" \\ --identifier \"<deployment identifier>\" \\ --timestamp \"<timestamp>\" \\ [ --system \"<system>\" ] The command automatically reports all commits done between the previous deployment and the HEAD of the Git repository as changes that belong to the deployment being reported.","title":"Using Git"},{"location":"cli/pushing-data-to-pulse/#without-using-git","text":"If you don't use Git or prefer to have more fine-grained control over the information that you send when reporting changes and deployments, send separate reports for each change and deployment as described below. Tip If you're using Git, it's simpler to report changes and deployments together. Send the following information when reporting changes to Pulse: Field Description Format identifier The commit identifier. String timestamp Time when the commit was first pushed to the repository. Number (Unix epoch timestamp in seconds) system Optional. Repository or component to assign to this event. String Run the following command to report each change: Linux and macOS ./pulse-event-cli push change \\ --api-key \"<API key>\" \\ --identifier \"<change identifier>\" \\ --timestamp \" $( date +%s ) \" \\ [ --system \"<system>\" ] Windows event-cli.exe push change \\ --api-key \"<API key>\" \\ --identifier \"<change identifier>\" \\ --timestamp \"<timestamp>\" \\ [ --system \"<system>\" ] Send the following information when reporting deployments to Pulse: Field Description Format identifier Version number or another unique identifier of the deployment. String timestamp Time when the deployment finished. Number (Unix epoch timestamp in seconds) system Optional. Repository or component to assign to this event. String Commit identifiers included in the deployment. String (space-separated list) Run the following command to report each deployment: Linux and macOS ./pulse-event-cli push deployment \\ --api-key \"<API key>\" \\ --identifier \"<deployment identifier>\" \\ --timestamp \" $( date +%s ) \" \\ [ --system \"<system>\" ] \\ <space-separated list of commit identifiers> Windows event-cli.exe push deployment \\ --api-key \"<API key>\" \\ --identifier \"<deployment identifier>\" \\ --timestamp \"<timestamp>\" \\ [ --system \"<system>\" ] \\ <space-separated list of commit identifiers>","title":"Without using Git"},{"location":"cli/pushing-data-to-pulse/#incidents","text":"Report an event to Pulse whenever an incident resulting from a release or infrastructure configuration change to production is solved. Incidents are any form of degraded service that require remediation: The incident is created when you detect a service impairment or service outage in production. The incident is resolved when you apply a hotfix or patch, or when you rollback the changes to restore the service in production. Typically, it's possible to keep track of this information using your monitoring infrastructure or your ticketing system. Pulse uses these reports to calculate the metrics Median time to recovery and Change failure rate . Send the following information when reporting incidents to Pulse: Field Description Format identifier A unique identifier of the incident. String timestampCreated Time when the incident started or was detected. Number (Unix epoch timestamp in seconds) timestampResolved Time when the incident was resolved. Number (Unix epoch timestamp in seconds) system Optional. Repository or component to assign to this event. String Run the following command to report each incident: Linux and macOS ./pulse-event-cli push incident \\ --api-key \"<API key>\" \\ --identifier \"<incident identifier>\" \\ --timestampCreated \"<timestampCreated>\" \\ --timestampResolved \" $( date +%s ) \" \\ [ --system \"<system>\" ] Windows pulse-event-cli.exe push incident \\ --api-key \"<API key>\" \\ --identifier \"<incident identifier>\" \\ --timestampCreated \"<timestampCreated>\" \\ --timestampResolved \"<timestampResolved>\" \\ [ --system \"<system>\" ]","title":"Incidents"},{"location":"metrics/accelerate/","text":"Accelerate metrics \u00b6 Pulse calculates the four key Accelerate metrics using strictly changes , deployments , and incidents data for a rolling window of the last 90 days: Deployment frequency Lead time for changes Median time to recover Change failure rate Deployment frequency \u00b6 How often your organization completes a deployment to production or releases code to end-users of your primary application or service: number of deployments per day Pulse uses the average value over a period of time to display aggregate deployment frequencies. Pulse determines your performance level for this metric as follows: Performance level 1 Deployment frequency Elite More than 50% of days have one or more deployments High More than 50% of weeks have 3 or more days with a deployment Medium More than 50% of weeks have at least one deployment Low More than 50% of months have at least one deployment Lead time for changes \u00b6 How long it takes a commit to get into production on your primary application or service: median(deployment timestamp - changes timestamp) Note The changes timestamp is when code is actually checked into a repository. Pulse uses the maximum value over a period of time to display aggregate lead time for changes. Pulse determines your performance level for this metric as follows: Performance level 1 Lead time for changes Elite Less than 1 day High Between 1 day and 1 week Medium Between 1 week and 1 month Low More than or equal to 1 month Median time to recover \u00b6 How long it takes your organization to recover from a failure in production (e.g., service impairment or unplanned outage): median(incident resolved timestamp - incident created timestamp) Pulse uses the maximum value over a period of time to display aggregate median times to recover. Pulse determines your performance level for this metric as follows: Performance level 1 Median time to recover Elite Less than 1 hour High, Medium 2 Less than 1 day Low More than or equal to 1 week Change failure rate \u00b6 Percentage of deployments causing a failure in production (e.g., service impairment or unplanned outage) and that subsequently require remediation: number of deployments that caused incidents / total number of deployments Pulse uses the average value over a period of time to display aggregate change failure rates. Note We decided to avoid requiring a relationship between incidents and deployments or changes to simplify the data model reported. As such, Pulse considers the deployment that caused an incident the closest deployment before the start of that incident . The same deployment might be responsible for multiple incidents. Pulse determines your performance level for this metric as follows: Performance level 1 Change failure rate Elite, High, Medium 2 0-15% Low 15-100% Performance levels are based on the State of DevOps 2019 . \u21a9 \u21a9 \u21a9 \u21a9 Means are not significantly different based on Tukey's post hoc analysis ( State of DevOps 2019 pp. 18). \u21a9 \u21a9","title":"Accelerate metrics"},{"location":"metrics/accelerate/#accelerate-metrics","text":"Pulse calculates the four key Accelerate metrics using strictly changes , deployments , and incidents data for a rolling window of the last 90 days: Deployment frequency Lead time for changes Median time to recover Change failure rate","title":"Accelerate metrics"},{"location":"metrics/accelerate/#deployment-frequency","text":"How often your organization completes a deployment to production or releases code to end-users of your primary application or service: number of deployments per day Pulse uses the average value over a period of time to display aggregate deployment frequencies. Pulse determines your performance level for this metric as follows: Performance level 1 Deployment frequency Elite More than 50% of days have one or more deployments High More than 50% of weeks have 3 or more days with a deployment Medium More than 50% of weeks have at least one deployment Low More than 50% of months have at least one deployment","title":"Deployment frequency"},{"location":"metrics/accelerate/#lead-time-for-changes","text":"How long it takes a commit to get into production on your primary application or service: median(deployment timestamp - changes timestamp) Note The changes timestamp is when code is actually checked into a repository. Pulse uses the maximum value over a period of time to display aggregate lead time for changes. Pulse determines your performance level for this metric as follows: Performance level 1 Lead time for changes Elite Less than 1 day High Between 1 day and 1 week Medium Between 1 week and 1 month Low More than or equal to 1 month","title":"Lead time for changes"},{"location":"metrics/accelerate/#median-time-to-recover","text":"How long it takes your organization to recover from a failure in production (e.g., service impairment or unplanned outage): median(incident resolved timestamp - incident created timestamp) Pulse uses the maximum value over a period of time to display aggregate median times to recover. Pulse determines your performance level for this metric as follows: Performance level 1 Median time to recover Elite Less than 1 hour High, Medium 2 Less than 1 day Low More than or equal to 1 week","title":"Median time to recover"},{"location":"metrics/accelerate/#change-failure-rate","text":"Percentage of deployments causing a failure in production (e.g., service impairment or unplanned outage) and that subsequently require remediation: number of deployments that caused incidents / total number of deployments Pulse uses the average value over a period of time to display aggregate change failure rates. Note We decided to avoid requiring a relationship between incidents and deployments or changes to simplify the data model reported. As such, Pulse considers the deployment that caused an incident the closest deployment before the start of that incident . The same deployment might be responsible for multiple incidents. Pulse determines your performance level for this metric as follows: Performance level 1 Change failure rate Elite, High, Medium 2 0-15% Low 15-100% Performance levels are based on the State of DevOps 2019 . \u21a9 \u21a9 \u21a9 \u21a9 Means are not significantly different based on Tukey's post hoc analysis ( State of DevOps 2019 pp. 18). \u21a9 \u21a9","title":"Change failure rate"},{"location":"metrics/lead-time-reviews/","text":"Lead time and review metrics \u00b6 Lead time for changes and review metrics provide an extra level of detail about the performance of your team workflows. Lead time for changes sub-metrics \u00b6 The following metrics directly influence Lead time for changes , and can help you track in more detail what needs to be improved in your workflow: Time to open Time to merge Pulse aggregates these metrics by week and presents values for the average and the 5%, 25%, 75%, and 95% percentiles. Note Pulse calculates these metrics based on pull request data and: Includes draft pull requests, meaning that the lifetime of pull requests includes the time marked as draft Excludes open and declined pull requests Excludes pull requests without commits and force pushed pull requests where the first commit was authored after the pull request was open Time to open \u00b6 An approximation of how long it takes for a change or feature to be developed: pull request open timestamp - first commit in pull request branch timestamp Time to merge \u00b6 How long does the code review process take for a change or feature: pull request merge timestamp - pull request open timestamp Review metrics \u00b6 The following metrics provide insights into the level of engagement and efficiency of your code review process: Time to first review Time to first approval Time from first to last approval Time from last approval to merge Outlier review details Note Pulse calculates these metrics based on pull request data and: Considers that reviews are approvals, change requests, and inline pull request comments, but not pull request conversation comments Excludes reviews and approvals that are done after the pull requests are merged. Time to first review \u00b6 How long does it take to have the first review on a pull request: first review timestamp - pull request open timestamp Time to first approval \u00b6 How long does it take to have the first approval on a pull request: first approval timestamp - pull request open timestamp Time from first to last approval \u00b6 How long does it take between the first and last approvals on a pull request: last approval timestamp - first approval timestamp Time from last approval to merge \u00b6 How long does it take to merge a pull request after the last approval: pull request merge timestamp - last approval timestamp Outlier review details \u00b6 Pulse displays the following details for each pull request in the chart Review time explorer : Name Description Time to review Time to merge a pull request Changes Number of lines of code changed in a pull request Commits Number of commits in a pull request, even if the pull request is squashed Comments Number of comments and review comments in a pull request","title":"Lead time and review metrics"},{"location":"metrics/lead-time-reviews/#lead-time-and-review-metrics","text":"Lead time for changes and review metrics provide an extra level of detail about the performance of your team workflows.","title":"Lead time and review metrics"},{"location":"metrics/lead-time-reviews/#lead-time-for-changes-sub-metrics","text":"The following metrics directly influence Lead time for changes , and can help you track in more detail what needs to be improved in your workflow: Time to open Time to merge Pulse aggregates these metrics by week and presents values for the average and the 5%, 25%, 75%, and 95% percentiles. Note Pulse calculates these metrics based on pull request data and: Includes draft pull requests, meaning that the lifetime of pull requests includes the time marked as draft Excludes open and declined pull requests Excludes pull requests without commits and force pushed pull requests where the first commit was authored after the pull request was open","title":"Lead time for changes sub-metrics"},{"location":"metrics/lead-time-reviews/#time-to-open","text":"An approximation of how long it takes for a change or feature to be developed: pull request open timestamp - first commit in pull request branch timestamp","title":"Time to open"},{"location":"metrics/lead-time-reviews/#time-to-merge","text":"How long does the code review process take for a change or feature: pull request merge timestamp - pull request open timestamp","title":"Time to merge"},{"location":"metrics/lead-time-reviews/#review-metrics","text":"The following metrics provide insights into the level of engagement and efficiency of your code review process: Time to first review Time to first approval Time from first to last approval Time from last approval to merge Outlier review details Note Pulse calculates these metrics based on pull request data and: Considers that reviews are approvals, change requests, and inline pull request comments, but not pull request conversation comments Excludes reviews and approvals that are done after the pull requests are merged.","title":"Review metrics"},{"location":"metrics/lead-time-reviews/#time-to-first-review","text":"How long does it take to have the first review on a pull request: first review timestamp - pull request open timestamp","title":"Time to first review"},{"location":"metrics/lead-time-reviews/#time-to-first-approval","text":"How long does it take to have the first approval on a pull request: first approval timestamp - pull request open timestamp","title":"Time to first approval"},{"location":"metrics/lead-time-reviews/#time-from-first-to-last-approval","text":"How long does it take between the first and last approvals on a pull request: last approval timestamp - first approval timestamp","title":"Time from first to last approval"},{"location":"metrics/lead-time-reviews/#time-from-last-approval-to-merge","text":"How long does it take to merge a pull request after the last approval: pull request merge timestamp - last approval timestamp","title":"Time from last approval to merge"},{"location":"metrics/lead-time-reviews/#outlier-review-details","text":"Pulse displays the following details for each pull request in the chart Review time explorer : Name Description Time to review Time to merge a pull request Changes Number of lines of code changed in a pull request Commits Number of commits in a pull request, even if the pull request is squashed Comments Number of comments and review comments in a pull request","title":"Outlier review details"},{"location":"metrics/work-in-progress/","text":"Work in progress metrics \u00b6 Pulse calculates the work in progress metrics based on the status of all pull requests targeting any base branch in your GitHub repositories. Important You must install the GitHub integration for Pulse to calculate the work in progress metrics. Work in progress \u00b6 To provide you with an high-level view of the current work in progress of your teams, Pulse groups pull requests that are currently open by the following phases: Open: the pull request is open but the team hasn't reviewed it. Reviewed: the pull request received at least one review but it isn't approved yet. These reviews include change requests and inline pull request comments, but don't include conversation comments. Approved: the pull request received at least one approval. Work in progress details \u00b6 The following metrics for each open pull request allow you to understand which work items are about to become or have become blockers and may need an action to move forward: Time in progress: time since that pull request is in progress. Phase: current phase of the pull request, can be one of Open , Reviewed , or Approved . Reviews: number of reviews of the pull request. Reviews include approvals, change requests, and inline pull request comments, but don't include conversation comments. Comments: number of comments of the pull request. Comments include inline pull request comments and conversation comments. Time stale: number of days since the pull request had the last interaction. Changes: number of lines of code changed by the pull request.","title":"Work in progress metrics"},{"location":"metrics/work-in-progress/#work-in-progress-metrics","text":"Pulse calculates the work in progress metrics based on the status of all pull requests targeting any base branch in your GitHub repositories. Important You must install the GitHub integration for Pulse to calculate the work in progress metrics.","title":"Work in progress metrics"},{"location":"metrics/work-in-progress/#work-in-progress","text":"To provide you with an high-level view of the current work in progress of your teams, Pulse groups pull requests that are currently open by the following phases: Open: the pull request is open but the team hasn't reviewed it. Reviewed: the pull request received at least one review but it isn't approved yet. These reviews include change requests and inline pull request comments, but don't include conversation comments. Approved: the pull request received at least one approval.","title":"Work in progress"},{"location":"metrics/work-in-progress/#work-in-progress-details","text":"The following metrics for each open pull request allow you to understand which work items are about to become or have become blockers and may need an action to move forward: Time in progress: time since that pull request is in progress. Phase: current phase of the pull request, can be one of Open , Reviewed , or Approved . Reviews: number of reviews of the pull request. Reviews include approvals, change requests, and inline pull request comments, but don't include conversation comments. Comments: number of comments of the pull request. Comments include inline pull request comments and conversation comments. Time stale: number of days since the pull request had the last interaction. Changes: number of lines of code changed by the pull request.","title":"Work in progress details"}]}